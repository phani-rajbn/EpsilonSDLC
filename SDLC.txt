Software Engineer vs Software Developer?
A software engineer is a professional who applies the principles of software engineering for designing, development, maintenance, testing, and evaluation of the computer software. This would usually involve a team of engineers each of them involved in making the software. 

Software developers are professionals who build the software to run on a specific computer or various types of computers. They are always targetted on a certain domain on which they develop the software. They use tools for developing the software. 

Key differences:
Software engineering as team activity while the software developer is primarily a solitary activity. 
S/w Engineer might work directly with a certain hardware and other components of the hardware systems whereas S/w developer writes a programs that runs on a certain hardware. 
S/w engineer creates the tools to develop the software while s/w developers use the ready made tools to build the apps. 
s/w engineer tends to work/solve issues on a much larger scale of audience whereas the s/w developers tend to to everything on a limited scale targetting a certain domain or audience. 

Career paths: Software engineer: S/w Engineer, Principal S/w Engineer, Lead s/w development engineer. 
Software developer: Developer, S/w Architect, Management level. 


best practises for s/w engineer:
They work in such a way that it is beneficial to both the client and the employer. 
Ensure that the products should meet the highest professional stds...
Able to maintain the integrety and independence in their professional approach. 
Should be supportive of their colleagues. 

best practises for s/w developer:
Focused to completing the software to drive the overall business of the client. 
Uses the code efficiently in the project.
Write the daily coding goals and completing it. 
Planning on how to apprach the immediate coding task. 

----------------Software Development Life Cycle-----------------------------------------
SDLC is a process that creates a structure of development of the software. 

What is SDLC?
"SDLC is a systemmatic process for building the software that ensures the qualitity and correctness of the software built.  It aims to produce high quality software that meet the customer expectations. The System developement shouild be complete in a pre-defined time frame and cost. It contains a detailed plan which explains how, what to build, maintain the specifc software. Each of these phases has its own process and deliverables that feed into the next phase. SDLC stands for Software development life cycle".

Why SDLC?
It provides a basis for project planning, scheduling and estimation. 
It gives a framework for a std set of activites and deliverables. 
It provides a mechanism of project tracking and control. 
Increases the visiblity of the project planning that involves all the stack holders of the development process. 
It increases the development speed of the software development. 
It makes U anticipate the project risks and the management plan overheads and be prepared for it. 
The process will be mostly fool-proof so it improves the client relations. 

SDLC Phases:
Requirement Collection and analysis: 
First Stage of the SDLC process. 
Conducted by senior Team members with inputs from all the stack holders and domain experts.
Gives the clear picture of the scope of the project, current status, and expections as outcome of the project. 
Anticipate issues and directions for the flow of the project. 
Need a lot of expertise in the domain as well as the project life cycle to finalize the necessary timeline to finish the work of that system. 

Feasibility study:
After the requirement gathering, U need to define and document software needs. This process is conducted with the help of 'Software requirement specification' (SRS Document). It include every part of the project process.  It includes 5 types of feasibility checks:
Economical: Can we complete the project within the budget or not?
Legal: handle the project as per the cyber laws of the client's country and other regulatory compliances. 
Operations: Can we create these operations which is expected by the client?
Technical: Whether the current system support this software. Need for external hardware devices,.
Schedule: Decide that the project can be completed within the given schedule or not. 

Design:
Here the software and the System design documents are prepared as per the requirement Spec(SRS). This helps define the overall system architecture. 
2 Types of Design Docs:
High Level Design Document:
Brief description and names of each of the modules that make up the software. Module is self contained unit that is a part of the solution to the project. A project is typically made of many modules. Each module has multiple use cases. Each Use case has actors, operations, and result outputs. 
An outline of the functionality of every module. 
Interface relationships and dependencies b/w the modules if any. 
Database tables identitifed along with their key elements. 
Complete architecture diagrams along with technology details. 

Low Level Design Document:
Functional logic of every module. 
DB Tables with type info and size. Relations if any.(Databases are sp software to store data either in the form of rows and columns called tables or collections using NoSQL Databases). 
Complete details of the interface. An interface is a conceptual group of operations that this module intends to perform but not sure about its execution in the current phase. 
Lists of Exceptions that each use case will raise. 
Complete the inputs and outputs for every module. 
Addresses all the dependency issues related to the module. 
Dependency is a term we use for the units that are to be provided for the current module to work. 
It defines the rules and methods of the module. The developers who develop this software should strictly adhere to the terms and terminologies of the document. This includes entity names, function names, parameters, return types and all the stack holders of the coding practise.
One repository will be created for all the developers and engineers to have a common place where people can view, checkin and add new code into this location. This is called as Code Repository. Software like Git which helps in maintaining the code within the group is used. 
Coding: 
Once the system design and the repository is created, developers start building the system by writing the required code using the pre-choosen programming language. In the codeing phase, tasks are divided as Modules and Units each assigned to individual developers. It is one of the longest phases of SDLC.  In this phase, the developer must adhere to the LLDD. He needs to follow certain predefined coding guidelines. Coding guidelines include the naming of programming structs like classes, structures, functions, variables, parameters for functions and many more. 
There is also a std for choosing the programming tools like compilers, debuggers, Code managers and use them for code developement.  
Developers also write unit test cases to provide test results for the units of code they develop. This feature is called as Unit testing which is the part of the coding phase. This testing is to test the code U have developed before U place them in the repository. 

Testing: 
Once the s/w is complete, it is deployed to a Testing environment. The testing team will test the functionality of the entire system thro E2E Testing(End to End) using Testing Automation tools like Selenium. This will ensure that the Entire App works as per the Client requirement. 
Here QA and the Testing teams might find bugs/defects which they message to the developers as TICKETS. The Developer Team fixes this bug and closes the tickets. Each closed Ticket is again sent for RETEST to the Testing Team and QA. This is a continuous Process until the software is made bug-free, stable and working as per the business requirement of the System. 
U have tools like Atlassian Jira which automates the testing process and reports all the results to all the stack holders of the application process. 

Installation/Deployementg on Production Server:
After the completed testing process, the final deployement process begins. Here Deployment complexities are tested and finally put in place. Production server issues are resolved here. Based on the feedback given by the project manager, the final software is released and tested on the actual client's machine. Here any changes like Usernames, passwords, File Systems will be set right using config files provided by the developer Teams. 

Maintenance: 
Once the customers start using the software, the following 3 activities might occur:
Bugs when the users do not provide the info that matches the system requirement. This might occur in some scenarios where the part is not at all tested. 
Upgradations for the software is to provide newer versions of the software.  
Enhancement.: Adding new features to the existing software. 
------------------------------------------------------------------------------------------------------------
Popular SDLC Models:
WaterFlow Model.(Followed in Epsilon)
Interative WaterFlow Model
ProTyping model
Evoluationary Model
Spiral Model.
RAD Model. 
Agile model(Followed in Epsilon).

------------------------------WaterFlow model---------------------------------
One of the oldest forms of software development methodoligies. This is the fundamental model based on which other models are designed and developed. In the course of time, this is now said as the most theoritical model and highly impractical for development. 
In this case, the outcome of the previous phase will become the input for the next phase. 
This is highly document-intensive where earlier phases documenting is what is needed to be performed in the subsequent phases. 

What is THE WATERFLOW MODEL?
"Water Flow Model is a sequential model that devides software development into pre-defined phases. Each Phase must be completed before the next phase could begin with no overlap b/w the phases. Each phase is designed for performing specific activity during the SDLC phase. It was introduced by Winston Royce in 1970". 

When to use this model?
Works well if:
Requirements are not changed frequently. 
Applications are not complicated and huge. 
Project spanned for short time(1 to 2 years). 
Requirements are clear. 
System environment dont change. 
Technology and tools used are not dynamic and is stable. 
Resources are very much available and well trained. 
Well Defined milestones. 

Disadvantages:
Clients cannot see the final output till the completion of the project. 
It is not desirable for complex projects where the requirments change frequently. 
Documentation takes a lot of time of the developers and Testers. 
Bugs are notified only after the software is completed.  
High risk of Uncertainity till the project is deployed. 


Incremental Model:
It is a process of s/w development where the requirements are broken down into multiple standalone modules of the SDLC. Incremental developments are done from analysis to maintenance in each such break up called Build. Each Iteration passes thro the Subrequirements, design, coding and Testing. 
Advantages:
The System is put into production when the first increment is delivered. Usually the first increment will be a core product where the basic requirements are addressed and suplimentary features are added in next increments. Once the core product is analyzed by the client, the plan for the next increment happens. (Not be always). 

Features:
System development is broken down into many mini development projects. 
Partial Systems are successively built to produce a final total System. 
Core Requirements are handled first and other features are enhanced later. 
Once the requirement is developed and deployed, the requirement for that increment gets frozen. 

When to use Incremental Models?
Requirements are clearly understood. 
Client demands an early release of the product. 
When s/w Team is not well skilled and trained. 
When High risks and goals are involved. 
Well suited for Web Application and product based Companies. 

Advantages:
Software could be developed quite quickly. 
It is less costly compared to others. 
Customers respond to each build. Any minor changes could be implemented without altering the existing build process. 
Errors can be identified at early stages. 

Disadvantages:
It requires a proper planning to break up the modules into core and dependency modules. 
It might cause problems due to system architecture not clearly understood and some requirements might be skipped totally, 
Each iteration is expected to be non overlappable which will not be the case usually. 
Rectifying a problem in one unit requires an ample corrections in all the units that consumes it leading a lot of time for maintainence. 

Spiral Model:
It is an combination of waterflow and iterative models. Each phase is a component with a design goal and ends with the client reviewing the progress.  The development team starts with a small set of requirements and goes thro each development phase for those set of requirements.  The Engineering team adds the functionality for the additional requirement in every increasing spirals until the app is ready for the production phase.  This feature itself leads to the Agile Model in the future software developments. 

When to use Spiral Methodology?
When the project is large and its releases are required to be frequent. 
When risks and cost evaluations are important. 
Well suited for medium and high risk projects. 
When the requirements are unclear and complex. 
Changes are anticipated at any time. 
When long term project commitment is not feasible due to changes in economic priorities. 

Disadvantages:
Risks of not meeting the schedule or budget is very high. 
It demands risk assesment expertise. 
It must be strictly followed for the smooth operation of the spiral model. 
It is very costly for smaller projects. 
Spirals can run indefinetly. 

V Model is an SDLC Model where the execution of the processes happens in a sequencial manner in a V Shape. This is also called as Verification and Validation Model.  It is an Extension of the WF model and is based on the association of a Testing phase for each corresponding development phase.  For every development Cycle, there will be a direct link to an appropriate Testing phase.  It is claimed to be highly diciplined model and like WF, the next phase starts after the previous phase is completed. 
Work starts with Business requirements, System Design, Architectural Design, Model Design, Coding phase, Validation phase, Unit Testing phase, Integration Testing, System testing, Acceptance Testing. 
When to go for V Model?
Requirements are well defined, clearly documented and fixed(WF Model). 
Product Defn is stable. 
As verification is done at every phase, there is no ambiguities and undefined requirements. 
Usefull for shorter projects. 

Advantages: They are simple and easy to understand. Well Suited for smaller projects where the requirements are small and well understood and will not differ.  As testing is done at every phase, there is a little scope or 0 scope of Error or mis management in the project. 

Disadvantages:
Uncertainity and high risk. 
Not good for OOP Design stds. 
Once the App is in testing phase, it is quite impossible to go back and make changes to the functionality, which makes it very similar to WF Model. 
There is working s/w that is developed based on this model. 
Documentation is very much and eats ur time as its created in every phase of development. 

Agile Methodology:
It is an improvised version of Iterative and Spiral model with focus on process adaptability and customer satisfaction by providing working software product in more quicker manner compared to other SDLC Models. Agile breaks the product into small incremental builds. Each build is enhanced thro Iterations. The Duration of each iteration is not more than 2 to 3 weeks. Each iteration will involve cross functional Teams parallelly working in the areas of Planning, requirement gathering, Designing, coding , Testing and Deployment.  Every iteration will result a working product which will be displayed to the client and the other stake holders. 

What is Agile?
Agile is a process/methodology that is built on a principle that every project is unique by itself. Every time, any existing projects could be tailor made to meet the new requirement that best suits the current trend. 
In Agile, tasks are divided into time boxes(Small Time Frames) to deliver the specific features for a release. The time for the release will not be more than 2 to 3 weeks. 
Iterative approach is taken and working software is developed for every iteration. Each build is incremental in terms of features, the final build might not be known to the current stream of developers. 
Each iteration will undergo: planning, req analysis, Design, coding, testing and deployement. all done within a small time frame. 
Immediately the next iteration requirement gathering happens. 
Because of its flexibility and limited risks, it is one of the most sought after methodology. Currently various tools and frameworks are available to support development thro Agile methodology. 
The Agile development follows certain principles called as Agile manifesto which is followed among the Agile development community.
Individuals and Interactions: Code is developed Individually and shared to all using iteractions within the teams. 
Working Sofware: It is good to show a existing working software to the client rather than pages of Documentation. 
Customer Collaboration: Continuos Customer interaction is required as both the client and the developer are not sure about the final product and need to talk quite frequently.  
Responding to the change: Agile focuses on quick responses to change and continuous Development
----------------------------Day 2--------------------------------------
What is agile methodology?
Agile methodology is an interactive approach for s/w dev. It is divided into iterations. Each iteration takes a short time of 1 to 4 weeks. It is designed to deliver the ever changing business requirement. It distributes the s/w with faster and fewer modifications. 
Each phase of development will span for 6 to 8 months. 
It is divided into ideas, defining, coding, integrating and finally testing

Roles in Agile:
Scrum Master: Team Leader and a facility provider who helps the team members to follow the agile practises and ensures that the team members meet their commitments and the customer requirements. 
Close Co-operation b/w the functions and the roles. 
Works with the Organization to keep in track the progress of the iteration. 
Ensures all the nessicities of the Team and ensures no disturbances will occur. 
Any blocks that interupts the progress will be handled by the Scrum master.
Practises of Agile:
Planned meetings, Daily standups, Demo, Review, Retrospecitive meets, facilitate the decision making process.   

Product Owner: he is the one who runs the product in the business point of view. He knows the in and out of the product: who uses it, what is the use of it, what is expected from it and final look of the product. 
He defines the requirement and priorities of the development phase. 
He sets the release dates and contents. 
Responsible for the iteration and releasing the planned meetings 
Prioritizes the process of development: which part is more important and ensures that important part be developed first. 
He is the bridge b/w the Customer and the Team who develops it. 
He will be accept the ideas of the team, ensures that it meets the requirements and finally approves the product before its delivered to the client. 

banking software for a Cooperative bank society
3 teams:
1 Team: Customer Management->Customers in the core banking. ->CMS(7)(5 weeks)
2 Team: Employee Management->Employees in the bank with various branches.->EMS(7)  
3. Team: Services Management->Banking services to the Customers: Transactions, operations, services.(6)  

Functional Teams:
Every agile team will have 5-7 members Usual experience will be 4-6 years. It consists of 3 Developers, 1 Testers, 1 Tech lead.  This might be +- 2 members. 

how it works? 
User Requirement:
Defines the requirements of the user in terms of functionalities. 
User case: The Functionality will be executed by this user to achieve this business requirement. 
This use case becomes User Story. 
User story has 2 parts: Requirement and the Task to complete the requirement. 
Requirement talks about what is to be done. It defines the needs of the user. 
Each such requirement is implemented by TASK. Task defines how that requirement is accomplished. It defines how the functionality be achieved. 
It is possible that each User requirement can be divided into multiple tasks if it is planned in the single iteration. 
User tasks are estimated in hour basis, scheduled b/w 2 to 10 hrs. 

Every requirement is validated using acceptance Testing 
Criteria for the Software acceptance test to pass: 
Functionality: The expected results are achieved for these inputs. 
Behavior: The feature is implemented
Performance. : Speed and no bugs. 
Final Output: Satisfactory result....

What is done after the successfull acceptance?
It should be delivered to the client for final approval. 
Changes and reviews have to be acknowledged. 
Requirement gathering for the next itertion. 
Team enhancements if required. 
-------------------------------------------------------
Advantages of Agile:
Customer satisfaction is fast, continuous.
Delivery is quick, and usefullness of the software is determined immediately. 
Product is delivered fast and frequently within weeks instead of months. 
Agile has smaller teams, so face to face interactions lead to best results.
A continous monitoring of the design and techincal excellence. 
Daily and close iteractions b/w the business people and the developers. 
Regular adaptation to the changing curcumstances. 
Even late changes in the requirements are handled with care without much hindarences.

Disadvantages:
Good for smaller projects. However big projects could be broken down to smaller projects and achievements are made. 
There is no need for high intensity of designing and documentation. 
Need of a experienced project member to tak crucial decisions in the meeting. 
Cost of the agile development is higher compared to other development methodologies. 
The project can go offtrack if the PM is not clear about the requirement and what outcomes he expects from it.

Exercise:
Analyze the Comparison b/w the Agile model and WaterFall Model.  

How agile is implemented?
SCRUM: Is a framework that helps Agile teams to work together. 
Scrum and Agile are not the same as Scrum is focused on continuous improvement which is basis of agile methodology. It implements Agile in making the workings to go together with different teams and products. 

Terms and Terminologies in SCRUM:
A product is developed using series of repetations called SPRINTS. It breaks down complex projects into small sized units which makes it more manageable, allows the teams to create high quality work, faster development and more frequent releases.

Sprints are short time boxed periods for the Scrum team to complete an amount of work. Right sprints will help the agile teams to ship better software. 

Sprint plan: Basically an cation in scrum that starts the sprint. Plan will define what can be delivered in that sprint It also tells how the work is achieved and is done with participation of all the scurm team members. It sets the period where all the work is to be done.  It solves the following questions: 
THE WHAT: The goal of the spring and the backlog items which contribute to the goal achievement, 
THE HOW: Planning of the nessasar work on how to achieve and deliver the sprint goal. 
THE WHO: The roles invoked in using this feature, It tells about the value the customer expects from this sprint.
THE INPUTS: The data and the resources required to start the sprint, 
THE OUTPUTS: The critical outcome of the sprint to meet.

Every Product has Product Backlog:  It is registered list of work for the development team. The Essential tasks is represented in the top of the product backlog and next steps will be notified below one after the other. The Developer team pulls the work from the product backlog. It is basicaly a roadmap and requirements. This will be designed by the product owner as a single list. This is called as Story. 

Imp Points: Each iteration is considered as SPRINT->Plan, Daily Scrum, Spring Review->Sprint Retro->Delivery. 
Product Backlog->list of things to be done during this product development.
Sprint backlog->List of things to be done during this current cycle. 
Review->Matches the expectations and the actuals. Limitations will addup to the backlog. 
-------------------------------------------------------------------------------
Daily Stand ups:
Its a term used to day-to-day status meetings on the project by the members of the agile team. It discusses the regular updates as well the problems of the team members:
Usually the meeting will be for 15 to 20 min. 
It discusses: what one did yesterday, what is planned today, if there are problems explain it.  
It is done on day to day basis irrespective of the location of the team members. 

What is said to be Done. 
In Agile, a Definition of DONE is in 3 different stages: User Story(Requiement), Iteration(Sprint) and Product Release(Delivery). 
Points to check:
For User Story:
All the code and documentation is checked in(Completed and uploaded to the code repository):GITHUB...
The product has passed all the Unit tests. 
All the acceptance Tests are completed. 
The Product owner has accepted the story. 
The Help Text is written

Iteration: 
Performance of the product is satisfactory. 
Product Back up is complete. 
User has accepted the requirement and is ready to move to the next iteration. 
Defected Products are fixed or postponed to the next iteration. 

Release:
The System satisifies the current System Configuration
Performance of the System in the environment. 
Data and software is secured or not. 
Bugs, Logs and recovery plans are tested.(DRP: Disaster Recovery Plans) 

Software development happens in Agile:
Development should happen on a sustainable manner. No gimmicks or heroic development. Invokes good estimation, effective branching strategy for managing the code. Code is automatically tested to protect the quality of the code. 
Code Best practises must be adhered to..
Set up and maximize the project management tools: Jira's release Hub. 
There should be a complete automation from the build to the release straight from the release hub. 
Use of Development and operational Tools like Docker and Kubernetes for containerization of the products. 

Tools for Agile Development:
JIRA Agile: Developed by a Atlassian. It is used for issue tracking, bug tracking, project management. Its dashboard contains lots of usefull functions to define a sprint, track them, maintain story boards and manage them. It can be downloaded and installed on multiple devices. 

Github: It is one of the largest distributable code management softwares available. Currently maintained by MS. Developers can store all kinds of code and its features for vast no of projects. It keeps track of record edits across the team in real time basis. It can be integrated into IDEs like VS Code, VS, Eclipse, Intellij...

PlanBox is a tool that tracks the progress of charts. 
---------------------------------------------------------------------------------------------------------------
Big Bang Model: 
In the big bang model, developers dont adapt any specific process oriented methodologies. Development begins with basic funding or no funding at all and Ur efforts become the inputs and output of the software developed might not be completely in agreement with the client. 
Major focus is on s/w development instead of planning, documentation and other things. The Requirements are understood thro an oftrack correspondence like chat, email or over phone. The requirements are enforced immediately. Any minor changes required will be injected without much trouble to the system. 
Well suited for a group of 3 -5 developers and majorly used in educational and practise projects. This is suited when the requirements are not well understood and the final date of release is not given. 

Advantages:
Simple model and less planning is required. 
Easy to manage as the size is small. 
No of services will be very less.
Changes can be done and hense flexible. 
Release date is not specified. 

Disadvantages:
Not good for long lasting projects. 
High risk of project completion or completion to 100%. 
Could be expensive if the requirements are misunderstood. 
-------------------------------------------------------------------------------------------------
Prototype Model:
Protyping means building a software with limited or basic functionality which may or may not hold the exact logic of the expected Software to be built.
Currently very popular, as it has benifits: From the customer point, he comes to know about the capability of the Developer and his scope of building the software to meed the requirement. The developers will have an understanding about the client requirements initially and get feedback about it very quickly and make the developer understand the expected behavior during the development of the product. 
It involves the step-by-step development in the following manner:
Basic requirement Identification: In terms of UI screens, functional features which might not satisfy the original intention, but the functionality is achieved in a round about manner. 
Developing the prototype: Initial Development happens to the prototype, UI Screens are shared and possible outputs are also presented. They might not behave as per the actual requirement, but will provide the functionality with mock data and mock objects. 
Review the prototype:The developed code is demoed to the customer, take feedbacks and is used to further enchance the product. 
Revise and enhancement:  Revision includes the requirements, time, budget and technical feasibility. The changes accepted are further enhanced to the product to give a new version with new feautures into the system. This cycle repeats till all the customer requirements are met. 
There are 2 types of Prototypes: Vertical and Horizontal:
Horizontal Prototyping displays the user with UI about the product and gives a broader picture of the entire system with focussing on any specific feature. Not all features are implemented but atleast will throw some light on the expected enhancements. Well suited for selling the product to various organizations. 
Vertical model is used when U want to provide indepth functionality of a perticular use case. These are more technical in nature and involve detail functionality of the sub system. Database, interactions, file alterations and so forth.....

Different prototypes:
Throw away Type: One model is created, once approved, it is discarded and create an new program for the client as a real time project.  In this case, the prototype is created with minimal and limited requirement gathering. Once the actual requirement is understood, a new system will be created discarding the existing prototype(Things are created from the scratch). This is also called as RAPID Prototyping or Close ended prototying. 

Evolutionary type:
Core features are implemented in the prototype itself and other requirements are gathered and added as when its required. The current product becomes the heart of the complete system and other organs of the system will be added on need basis. The well understood requirements are completed first and others later. 

Incremental Type:
Here we create multiple ready to use prototypes and finally stitch them together to meet the requirement. based on the inputs we integrate the required ready to use prototypes into a final product and deliver to the client. 

Extreme Type: In web and mobile app development, we use this kind of prototyping.  We divide our development into 3 phases: One phase will give the UI Prototype like HTML pages, UI Screens to the client(Almost all). 
Phase 2 will contain the data processing components like DAL Components, Services are created to link with the UI. 
Phase 3 will invoke the integrations of phase1 and phase2. 

Advantages:
High level of involement from both the ends(Developers and Customers). 
U program for the missing functionalities. 
Reduces the time and costs as defects can be deducted much easier. 
Users get clear understanding of the product as they will have running product with them and easy to adapt. 

Disadvantages:
As the original plan is unknown, some prototypes might be useless, but still u would spend time and resources. 
Users will find hard to differenciate the actuals and prototypes. 
Developers are forced to modify the prototypes with out understanding the feasibility of the project. 

RAD Model:(Rapid Application Development) is based on prototyping and interative development with no specific planning involved. RAD requirements are gathered using workshops where the Requirements will be generic. These generic models will further lead to create specific models based on the fine tuning done to meet individual software users. 

Software development:
Single Tier: Store some data, retrive the data in the most optimized manner and present the data in any visual format that is requested by the client. 
Principles:
Modularity: UR code should do one job at a time. Dont mix all the things into one function or one program. 
A Computer program is a set of instructions given to the machine which will interpret it and perform some operation as per the instructions. These programs are written in plain human readable syntaxes. These syntaxes are standardized by certain vendors like C, C++, Java, Python, PHP, C#, R and many more.  These are called as Computer languages. Based on UR language selection U create the instruction code called as PROGRAM. This Program is converted to a machine instruction code called as EXE. When U run this File, UR program executes.
The conversion of UR program to a machine code is called as BUILDING process. It includes compiling and building. Compilation is a syntax checking paridiam. The building is tailoring all the pieces of code to a sequence of execution. 
Syntactically UR program should be correct. Grammer, required nessicities should be provided before U can build the program. 
Entry point from where UR Program begins. usually this will be named as main method. UR program starts from here and ends if this main ends. Program terminates after the end of the main operation. Inside this main, U write instructions in the form of statements and expressions. 
U should not dump everything inside this main. Instead we will semantically group the statements into functions, creating them and calling them in main method....
A Single tier App is one which has all the programming constructs in one Executable. However the EXE has groupings done in the form of classes, functions, structs and many more. But everything is available within one Big Project. Usefull for smaller projects and limited no of developers. 

Multi Tier:
Divide UR Project into small precompiled units where one unit can be replaced with another if there is any problem. 

Service model: Services are sp Components grouped into functions which are exposed thro network protocols to be made available on multiple platforms. They can use protocols like TCP, HTTP, SMTP depending on what operations U want to perform.
Prominent services are available as REST Services: Functions that are invoked using Web based HTTP Methods: GET, PUT, POST, DELETE and transfer data across the platforms using JSON and XML.  
---------------------------------------------------------------------------------------------------------------
Tools : 
A Common place to store Ur Source code. 
Versioning of the code becomes problem. Changes made by different developers are not updated to all. 
Interaction with multiple users and all to come to a common platform is a question. 
Developers has to have secured place to store and any change made by any developer should be well documented and notified to all. There should be no denial from any one once its commited to the changes. 

Tool to organize the Code in a professional Manner. Version control System. It is a management tool for changes to be made to the documents, programs, code and large websites that keeps track of changes, collaborations within the team for better management of the resources. 
Every such change U make to those documents is called as VERSIONS.
Advantages:
Collaboration: Involves integrations of multiple documents into one. One user can modify other User's document.  Changes can be made to other documents and that changes are well documented in the system. 
VCS maintains snapshots of the versions identified by a Hash value and stored inside the repository. It is also documented about the time and the user with messages on what and when these changes were made. Version will be properly named accurately and should be easy to retrieve when ever we need. 
Backup: Most of the VCS, there will be 2 players: Central Repository and Local Repository. Central repository is the place where all the data is stored paramanently. Local Repository are local to each user and will pull the documents from the Central Store. If the local Store is gone, U still have the data from the Central Store, for some reasons if the central store crashes, U still have the local store with U.  Local Stores are stored in the respective user machines. 
Analyse: When any change is made to the documents, VCS provides proper description. What has changed and when it was changed. Therefore U can analyze how Ur project has evolved in the course of time and changes that are made in different versions. 
------------------------------------------------------------------------------------------
VCS Tools: Git, Bucket, mercurial, CVS, Subversion. The most populare are Git and Bucket. 
Git is maintained by Microsoft. 
BitBucket is maintained by Atlassian. 
According to FireFox analytical team, Git is 100 times more used than its nearest couterpart. It is the most widely used VCS available in the computing world. 
--------------------------------------------------------------------------------------------------
Git and GitHub:
Git is a distributed version control tool that supports distributed non linera work flows by providing data assurance for developing quality software. 
GitHub is the central repository of storing all the documents inside a cloud environment. 
Github will have multiple colaborators(Users) who have an installation of the repository in their respective machines using a tool called Git. Git is both Cmdline based as well as GUI based Environment. 
Collaborators pull the repository to their local machines, make changes to these local repository, commit those changes and finally push the modified data into the Github. Github keeps track of all the modifications, updations, including adding, removing, changing the documents in a time based version management. 
Features of git : Distributed, Compatible, Non-Linear, Branching, Lightweight, Speed, Open Source, Reliable, Secured and Economical. 
 What is a repository?
 It is a directory or a storage space where UR Projects, documents can reside. It will be local to a folder in Ur comp or it could be a storage spce on Github or another online Host. U can keep code files, Image Files, PDF Documents and many more inside it. 
 2 Types: Central repository and Local Repository 
Central Repository(GitHub): Located in a Remote server(Cloud).  It is distributed by the Username and his project details. It has a folder called .git which contains all the versions and management files. This will be the place meant for the team members to share and exchange the data. Any one can download or read the data, but very few can add or modify the data. 
Local Repository is created using GIT Tool. This will be typically in the local machine, Resides as a git folder inside UR Project's Root. Only admin of that machine can work with the repo.   
Interactions b/w the Local and the Github are handled by the Git Tool. U need to download the git inside UR machine. 

U need to create an Account in GitHub.
Once U login to UR Account, U could create a Repo. This will be the central repo for UR Project. 
Install Git in ur machine. Git is available as Bash and GUI. Programmers use BASH, Cmd line Utility for interacting with Central Repo. 
Create a folder to pull the central repo to Ur local machine. 
Open the folder thro Git Bash, a very colorfull cmd prompt specifically designed for handling git commands.(Windows).
---------------------------------------------------
Day 4:
DevOps: Development + Operations. 
The programmer will not only develop the Application but also will be responsible to handle the operations of the Application in the client side. VSS(Visual Source Safe) TFS(Team Foundation Server). 
It runs in my machine but not on the client machine. These issues were handled by the Operations team which had a basic idea on the app as well as trouble shooting the Config files.  These config files were written in XML, Currently JSON is used. XML was text based, so it was easy for a non tech guy to modify any changes that was required to make the app run. 
DevOps is one methodology which allow the developers to create an environment similar to VM where they actually develop the App and run it there it self. This image is what is shared to the User team and they simply run the App in the same environment as what the developer has created. 

Environments were created as Containers. Each container had one or more images of the Envinronment which was loaded, and the app would sit on that environment. App executes within the environment without worrying about the OS on which the User or the developer is working. Base OS should be the same for both the developer and the user. 

Docker is a container tool designed to benifit both the developers and operations. 
It allows to easily install and run the s/w without a need of external dependencies other than what is required to run the application. 
Docker will remove the never ending problem "CODE WORKS ONLY IN MY LAPTOP". 
Operations team will use the same docker environment shared by the developers so that it works as if it is running in the developer machine only. 
Helps in development of applications in an agile environment also as docker images are shared among the developers also. Like GitHub, U have Dockerhub which will allow to upload the Docker image into the certral repository and allow users and collaborators to use the image locally in their machines. 
Docker is not only used for deployment, it is also used for development. 
"DOCKER is an opern source centralized platform designed to create, deploy and run complex applications without worrying about the OS kernal system of the Environment".  It is different from Virtual Operating Systems as in this case, Dockers dont create new OS, it only creates containers to hold the Application on that OS. They share the OS kernel with other containers, It allows appliations to use the same Linux kernel as a system on the host computer, instead of creating a whole virtual OS. 


Docker has components: Client, Server, Machine, Hub and Composes. 
VMs create a virtual kernel and will be as if a new OS is sitting on UR machine. 
Docker Containers vs VMs:
Containers are created on existing OS as it uses the same kernel but a different distribution. There is no wastage of memory and Integrations within the containers are fast and efficient. 
VMs uses independent OS, with lots of memory used from the host machine and integration is slow as it will be more like machine to machine communication. 

Advantages of Docker:
Containers are faster to run. It uses less memory. it provides continuous deployment and testing environment. No need for external dependencies. It is a light weight virualization. it does not require the full OS to run the Apps. 

limitations:
Not good for Rich GUI based Applications. Its an overweight as U work on an additional Layer. Applications that talk to the OS will be slow. Dockers does not provide cross platform compatibility means if an app is designed to run in a docker container on windows, then it cant run on Linux or vice versa. 
U should have some knowledge of Unix and its programming to work in Docker images and programming languages like Java, PHP, Python, etc. 

Workflow of Docker:
Install the Docker client in UR machine. 
Open the Docker Cmd and Run the Docker commands. 
docker info: Display the info about Ur current docker client. 
docker container ls: Lists all the containers in Ur docker. 
docker image ls: lists all the images installed in ur docker. 

SOLID Principles in OOP. (C++):
Object Oriented programming is a programming technique to develop app software using Components called Classes and Objects. A Class is a user defined data type created to be used in that perticular program. This User defined type could be a virtual representation of a real time entity. 
Employee: Could be represented in UR Code by creating a class, and using the clas thro an object. object is like a variable of the class. class is basically a defn on what this entity will do, what will it contain and other features of the entity. A class defines what the entity will do. The real representation of the entity is the object of the class(Instance of the class). 
SOLID Principle: The principles that are to be followed while designing  a class and object in a program . The principles have internally lead to the concept of OOP features: Encapsulation, Inheritance, Polymorphism, Abstraction. 
S : Single Responsibility Principle
O: Open-Closed Principle. 
L: Luskov's Substitution Principle.
I: Interface Segregation Principle
D: Dependency Inversion Principle. 

Single Reponsibility: Each class should do only one job. Dont mix all the things into one. U need to create multiple classes for each of the semantically grouped operations. : Employee: id, name address, salary. 
Project: ProjectId, Name, Client, ContactPerson, StartDate, EndDate, Cost.
EmpManager: addEmployee, findEmployee, deleteEmployee, updateEmployee. (Repository) =>DataStorage: File, Database...
Modularity in UR code is achieved because of this principle. Multi layered Apps are developed as per this principle. 

Open-Closed: A Class is closed for modification but open for extension. leads to the concept of inheritance. Onc the class is created and used, it should not be modified. However Ur class could be extended into another class and any changes could be made to that class rather than UR class. 

Luskov's Substitution Principle: A Class object can be substituted by any of the sub class objects as long as their signature is not modified.  This principle is what is used in Runtime polymorphism. A Base class object can be instantiated to any of the derived types as long as the derived type has no additional operations. 

Interface Segregation Principle: U should create different interfaces to meet each and every client specific requirements instead of a general interface. 
Interface is a unit like a class but contains only definitions in them. It does not contain any implemention. 
Account: Id, name, address, contact, bal, calculateInterest, credit, debit....
With interface, one can create multiple implementations based on the same interface and substitute it thro RTP. 
CRUD: add, remove, update, delete.  

Dependency Inversion Principle: It is good to depend on abstraction istead of Concretions. If U have a function that returns a data type, it is good to have a function that returns its base type rather than its subtypes. For every subtype, U end up creating individual funtions which might not be feasible as new sub types could be created in the future. So to accomodate both existing as well as the future types, its good if UR code is working with abstract type(SUper base type) as all the current subtypes and new subtypes that will be created in the future will still retain the same functions but differ in their functionalities. 

-----------------------------------------------------------------------------------------
Intro to Jenkins, Jira. 
Jenkins is an app that allow to have a continuous integration and delivery of the project regardless of the platform U work. This app will help in automating various phases of app developed irrespective of the SDLC methodology U follow. It allows to integrate development, testing and deployement. This automation feature is enabled with GUI and Command line tools that will help in performing its operations at various phases: Once development happens, its automatted to move to Testing team which will internally return the results to the development team, if required the Development team reworks on the code which will further automate the testing team to perform the tests, once completed, it will automatically deploy to the respective environment if placed on the docker. The management of these could be done using container management tool called KUBERNETES.
U could download the Jenkins from the jenkins-cli-org which will help U in installing the Jenkins software, IT does not have a UI of its own, it rather depends ona browser that runs it. 

Jira: is a software testing tool that also maintains bug tracking and issue maintainance feature. In the recent times, it has upgraded to perform Automations based on agile methodology. It helps in managing the defects of the project, tasks of the project in the form of issues. U get a dashboard on which these operations of Agile hanlded. It will allow to implement agile either in the form of Scrum or Kanban. If U choose the SCRUM Project it will automate the process and allows users to invoke in the project management.
Features: Projects, Issues, Workflows, Dashboards....
Git, Dockers, Jira, Kubernetes.
























